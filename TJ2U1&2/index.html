<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Matching Game - Insects & House</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    body {
      font-family: Arial, "Microsoft JhengHei", sans-serif;
      background: #f5f5f5;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }

    h1 {
      margin: 10px 0 5px;
      font-size: 24px;
      text-align: center;
    }

    p.subtitle {
      margin: 0 0 15px;
      font-size: 14px;
      text-align: center;
    }

    #game-board {
      display: grid;
      grid-template-columns: repeat(5, minmax(60px, 100px));
      gap: 10px;
      justify-content: center;
      margin-top: 10px;
    }

    .card {
      width: 100%;
      padding-top: 100%;
      position: relative;
      perspective: 800px;
      cursor: pointer;
    }

    .card-inner {
      position: absolute;
      inset: 0;
      transition: transform 0.4s;
      transform-style: preserve-3d;
    }

    .card.flipped .card-inner,
    .card.matched .card-inner {
      transform: rotateY(180deg);
    }

    .card-front,
    .card-back {
      position: absolute;
      inset: 0;
      backface-visibility: hidden;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
      user-select: none;
      background: #ffffff;
      border: 2px solid #ccc;  /* åŠ é‚Šæ¡†ï¼Œè‡³å°‘çœ‹å¾—åˆ°æ ¼å­ */
    }

    .card-back {
      background: #ffd54f;
    }

    .card-back img {
      max-width: 80%;
      max-height: 80%;
    }

    .card-front {
      transform: rotateY(180deg);
      font-size: 20px;
      padding: 5px;
      text-align: center;
    }

    .card.word-card {
      color: #1565c0;
      font-weight: bold;
    }

    .card-front img {
      max-width: 90%;
      max-height: 90%;
    }

    #controls {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    button {
      padding: 6px 12px;
      border-radius: 6px;
      border: none;
      background: #42a5f5;
      color: white;
      font-size: 14px;
      cursor: pointer;
    }

    button:hover {
      filter: brightness(1.1);
    }

    #message {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
      min-height: 18px;
    }
  </style>
</head>
<body>
  <h1>Matching Game</h1>
  <p class="subtitle">é»ç¬‘è‡‰ç¿»ç‰Œ ğŸ”Š è½å–®å­—ï¼Œåœ–ï¼‹å–®å­—é…å°æˆåŠŸæœƒç•™ä¸‹ä¾†ï¼›å…¨éƒ¨å®Œæˆæœƒè‡ªå‹•å†ç©ä¸€å±€ã€‚</p>

  <div id="controls">
    <button id="reset-btn">é‡æ–°æ´—ç‰Œ</button>
  </div>
  <div id="message"></div>

  <div id="game-board"></div>

  <script>
    // åå€‹å–®å­—
    const words = ["ant", "bug", "bee", "window", "door", "house", "mad", "bat", "big", "bag"];

    const board = document.getElementById("game-board");
    const resetBtn = document.getElementById("reset-btn");
    const messageEl = document.getElementById("message");

    let cardsData = [];
    let firstCard = null;
    let secondCard = null;
    let lockBoard = false;
    let matchedCount = 0;

    // å»ºç«‹ word + image æˆå°è³‡æ–™ï¼Œä¸¦æ´—ç‰Œ
    function createCardsData() {
      const temp = [];
      words.forEach(word => {
        temp.push({ key: word, type: "word" });   // æ–‡å­—å¡
        temp.push({ key: word, type: "image" });  // åœ–ç‰‡å¡
      });

      // æ´—ç‰Œï¼ˆFisher-Yatesï¼‰
      for (let i = temp.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [temp[i], temp[j]] = [temp[j], temp[i]];
      }
      cardsData = temp;
    }

    // å»ºç«‹ç•«é¢ä¸Šçš„å¡ç‰‡
    function buildBoard() {
      board.innerHTML = "";
      cardsData.forEach((data, index) => {
        const card = document.createElement("div");
        card.classList.add("card");
        card.dataset.index = index;
        card.dataset.key = data.key;
        card.dataset.type = data.type;

        const inner = document.createElement("div");
        inner.classList.add("card-inner");

        // èƒŒé¢ï¼šç¬‘è‡‰åœ–ç‰‡ï¼ˆimages/smile.pngï¼‰
        const back = document.createElement("div");
        back.classList.add("card-back");
        const backImg = document.createElement("img");
        backImg.src = "images/smile.png";
        backImg.alt = "smile";
        // å¦‚æœç¬‘è‡‰åœ–æŠ“ä¸åˆ°ï¼Œå°±é¡¯ç¤º ğŸ˜Š
        backImg.onerror = () => {
          back.textContent = "ğŸ˜Š";
        };
        back.appendChild(backImg);

        // æ­£é¢ï¼šå–®å­—æˆ–åœ–ç‰‡
        const front = document.createElement("div");
        front.classList.add("card-front");

        if (data.type === "word") {
          front.classList.add("word-card");
          front.textContent = data.key;
        } else {
          const img = document.createElement("img");
          img.src = "images/" + data.key + ".png";
          img.alt = data.key;

          // å¦‚æœåœ–ç‰‡æŠ“ä¸åˆ°ï¼Œå°±é¡¯ç¤ºå–®å­—ï¼ˆä¸æœƒæ˜¯ç©ºç™½ï¼‰
          img.onerror = () => {
            front.removeChild(img);
            front.classList.add("word-card");
            front.textContent = data.key;
          };

          front.appendChild(img);
        }

        inner.appendChild(back);
        inner.appendChild(front);
        card.appendChild(inner);

        card.addEventListener("click", onCardClick);
        board.appendChild(card);
      });
    }

    // ç”¨ç€è¦½å™¨å…§å»ºèªéŸ³å¼•æ“ç™¼éŸ³ï¼ˆä¸æ˜¯ mp3ï¼‰
    function speakWord(word) {
      if (!("speechSynthesis" in window)) return;
      window.speechSynthesis.cancel();
      const utter = new SpeechSynthesisUtterance(word);
      utter.lang = "en-US";
      utter.rate = 0.9;
      window.speechSynthesis.speak(utter);
    }

    // é»å¡ç‰‡äº‹ä»¶
    function onCardClick(e) {
      if (lockBoard) return;

      const card = e.currentTarget;
      const isFlipped = card.classList.contains("flipped");
      const isMatched = card.classList.contains("matched");
      if (isFlipped || isMatched) return;

      card.classList.add("flipped");

      const word = card.dataset.key;
      speakWord(word);

      if (!firstCard) {
        firstCard = card;
        return;
      }

      if (card === firstCard) return; // åŒä¸€å¼µå¡ï¼Œç„¡æ•ˆ

      secondCard = card;
      lockBoard = true;

      checkForMatch();
    }

    // æª¢æŸ¥æ˜¯å¦é…å°æˆåŠŸ
    function checkForMatch() {
      const isSameWord = firstCard.dataset.key === secondCard.dataset.key;
      const isDifferentType = firstCard.dataset.type !== secondCard.dataset.type;

      if (isSameWord && isDifferentType) {
        // âœ… é…å°æˆåŠŸ
        firstCard.classList.add("matched");
        secondCard.classList.add("matched");
        matchedCount += 2;
        setMessage("ğŸ‘ Good job! æ‰¾åˆ°ä¸€å°äº†ï¼");
        resetSelection();

        // å…¨éƒ¨é…å°å®Œæˆ â†’ é¡¯ç¤ºè¨Šæ¯ã€ç¨å¾Œè‡ªå‹•é‡æ–°é–‹å§‹
        if (matchedCount === cardsData.length) {
          setMessage("ğŸ‰ All matched! Great work! é¦¬ä¸Šå†ä¾†ä¸€å±€ï½");
          setTimeout(() => {
            resetGame();
          }, 1500);
        }
      } else {
        // âŒ é…å°å¤±æ•— â†’ ç¿»å›å»
        setTimeout(() => {
          firstCard.classList.remove("flipped");
          secondCard.classList.remove("flipped");
          resetSelection();
        }, 800);
      }
    }

    function resetSelection() {
      [firstCard, secondCard] = [null, null];
      lockBoard = false;
    }

    function setMessage(text) {
      messageEl.textContent = text;
    }

    function resetGame() {
      matchedCount = 0;
      firstCard = null;
      secondCard = null;
      lockBoard = false;
      setMessage("");
      createCardsData();
      buildBoard();
    }

    resetBtn.addEventListener("click", resetGame);

    // ä¸€é–‹å§‹å…ˆå•Ÿå‹•ä¸€å±€
    resetGame();
  </script>
</body>
</html>
